<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenMoCo AVR Libraries: The MoCoBus Protocol</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenMoCo AVR Libraries
   </div>
   <div id="projectbrief">Motion Control and MoCoBus Libraries for the AVR Platform</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('mocobus.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">The MoCoBus Protocol </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The MoCoBus protocol is designed for speaking to multiple devices connected to the same bus. All communication is handled in a sequence of structured packets: master devices on the bus send commands, and node devices act and respond to them.</p>
<p>While the MoCoBus AVR libraries are designed around RS-485 buses, nearly any transport layer could be supported that allows for multiple independent devices to exist on the same bus. This protocol defines how commands and responses are issued.</p>
<p>The MoCoBus protocol serves as a light-weight mechanism for speaking to and controlling multiple devices running simple microprocessors. It is intended to act as an in-between protocol where the complexities of a full-weight TCP/IP implementation are undesireable or impossible to support, yet the need for a robust transport with the ability to determine the successful receipt of messages is required.</p>
<p>Like most protocols for use with directly connected devices, each device must have an address assigned to it.</p>
<p>Much of this document will discuss the low-level implementation, including packet structure and timing. This document serves as the technical documentation for the protocol its self, and those who wish to use the OpenMoCo AVR libraries will find that the <a class="el" href="class_o_m_mo_co_master.html" title="MoCoBus Master Library.">OMMoCoMaster</a> and <a class="el" href="class_o_m_mo_co_node.html" title="MoCoBus Node Library.">OMMoCoNode</a> classes abstract these complexities away and provide a simple interface via high-level methods.</p>
<h1><a class="anchor" id="bustypes"></a>
Types of Devices</h1>
<p>A bus is a series of devices all sharing a common set of communication wires. All devices on a bus can speak to each other - but only one at a time. Most devices on a bus will be there to perform some specific activity, such as moving a motor. These devices, in most cases, will be dedicated to the task they perform, and not to providing a human interface - these are node devices. They accept commands and react to them.</p>
<p>Another type of device on the bus is one which provides a human interface, or acts on behalf of some other interface to command these node devices. These are the master devices.</p>
<p>As only one device may speak at a time, initiating commands is left to the master nodes. Of course, this generally means only one master may be active at any given time.</p>
<center><div class="image">
<img src="busmastnode.png" />
</div>
</center><p>Each node device must be assigned a unique address - master devices may only send commands and read responses, and therefore are all given the same address of 0.</p>
<h1><a class="anchor" id="busproto"></a>
The Basic Protocol</h1>
<p>The basic protocol uses structured packets to communicate information between nodes. Each packet uses a predictable sequence of bytes that enables a microcontroller-based device to quickly determine if the packet is intended for it, or not.</p>
<p>Every MoCoBus packet consists of up to two parts: the packet header, and the packet data (payload). Every packet must have a header, at a minimum, but additional data beyond the header is not required. The header is a ten-byte sequence and consists of four key sections: the break sequence, the target address, the packet code, and the data length.</p>
<center><div class="image">
<img src="pktheader.png" />
</div>
</center><p><b>The Break Sequence</b> is a series of bytes which indicates the start of a packet. This sequence is always defined as five null bytes followed by the value 255 (or, 0xFF). As each device on a bus will see all traffic destined to any device on the bus, the break sequence serves as an indicator that a packet has begun. This allows a node that is powered on in the middle of a command to another node, for example, to quickly understand that it is missing part of the packet and to ignore any further data until a proper start sequence is read. In this way, one may safely communicate with a device, no matter the current state of any other device on the bus. <em>As the break sequence is a reserved sequence of bytes, it must never be repeated in the payload for a packet. This is not of concern unless you are sending a sequence of raw bytes greater than 4-bytes in length. In such cases one must take care to ensure that this sequence cannot be repeated - by padding multi-byte values, or using ascii strings for example.</em></p>
<p><b>The Target Address</b> section is a two-byte value representing the address of the device which the packet is destined for. At this time, only the least significant byte of this value is utilized - limiting the address values between 0 and 255. The additional byte is reserved for future address expansion, if needed.</p>
<p>The address 0 is reserved for responses to Master nodes, and the address 1 is reserved for broadcast commands (see <a class="el" href="mocobus.html#busbcast">Broadcast Commands</a> below). This leaves the addresses 2-255 available for use by nodes.</p>
<p><b>Packet Code</b> is a special header section, it defines a particular code for the packet which represents a command or response value to the target of the packet.</p>
<p><b>The Data Length</b> section specifies how many additional bytes of data accompany the packet as data, or payload. The maximum payload allowed per-packet is 32 bytes. If zero is specified for a packet, no additional data bytes may follow.</p>
<hr/>
<p>There are two core types of packets which can be sent: command packets and response packets.</p>
<p><b>Command Packets</b> are sent by a master device to a node device. They use the packet code to represent a primary command to the node. They may also include up to 32 bytes of additional data in the payload, and there is no explicit structure to this payload (it is defined by the node and usually exposed to a master through an interface class). A command code sent by a master must be greater than 0, and the command code 1 is reserved for core protocol commands that every node device must support, such as identifier, version, and bus protocol version. This leaves 253 possible one-byte commands which can be sent to any node. For any node device type requiring more commands, sub-commands may be sent as part of the data payload. These packets are addressed to a specific device, and that devices address appears in the address section. All other devices must accept, and then discard this packet.</p>
<p><b>Response Packets</b> are sent by a node device to a master's command packet. There are only two possible packet codes, in this case referred to as a <em>response code</em>, allowed: 0 for error, and 1 for success. All node devices must begin transmitting their response to the master within 100mS, and each additional byte in the response must come within 100mS of a previous byte, otherwise the node will be timed out.</p>
<p>All response packets must be addressed to the address 0, which is reserved for responses back to the master.</p>
<p>If a node wishes to send data in response to the master's command, it must add a byte immediately following the payload length byte, which specifies which kind of data the node is responding with. This enables masters to quickly and easily distinguish the response data, and enables nodes to offer different data responses based on system conditions without requiring additional hand-shaking complexity. Six key data types are available, all represented by constants. For more information on these constants, see <a class="el" href="ommaster.html#masterdata">Receiving Data from the Node</a> in the Master tutorial. Note that the data type value byte must be included in the data length. The following diagram shows a hypothetical command packet and response packet in a session between a node and master.</p>
<center><div class="image">
<img src="resppkt.png" />
</div>
</center><h1><a class="anchor" id="busbcast"></a>
Broadcast Commands</h1>
<p>There are times, of course, where one will want to send a signal to all nodes and have them execute a common command at the same time. Notably, for all nodes that support a programmitic operation (i.e. configure node, and then tell it to start operating based on configured parameters) you would want them to start at the same time, without having to send start commands to each individually. Likewise, you'd want them to all stop at the same time.</p>
<p>MoCoBus supports a base set of broadcast commands, which any node type has the option of implementing. All broadcast commands are response-less, that is - nodes will act on them, or not, but no response will be received by a master. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Jun 17 2012 13:59:32 for OpenMoCo AVR Libraries by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>
